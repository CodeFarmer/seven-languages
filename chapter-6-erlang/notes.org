* Like

- Super good Emacs integration
  - M-x erlang-shell out of the box

- List literals, tuples and atoms are always nice
- since the book, Erlang has gained map literals too
  #{ a => 1, b => 2 }

* Dislike

- Oh my God the error messages
  - It's like Prolog but without the conceptual lens
  - "Bad function arity" when you mean "you forgot the list around the exports"
  - "head mismatch" when you mean "looks like you're matching in the wrong arity"
    - or, even better, "you had a capitalization typo in the function name"
  - "call to local/imported function isWordChar/1 is illegal in guard"

- Calling functions in guards is illegal and I don't even care why
  - http://erlang.org/pipermail/erlang-questions/2010-December/054862.html

- Associative arrays as lists of pairs is so oldskool
  - modern Erlang has sorted this out: #[ 1 => 2 , a => 4 ]
  - Common Lisp :P

- exporting things by arity
  - unless you can just not do that?

* Day 1

- List magically becoming a string when it's got ascii values - does
  this matter, or is it a REPL quirk?

- is the attempt to assign a value to an atom a hint about the lesson of assignment and equality?
  - don't use the same syntax for both of those
    - wait, "= is actually a pattern match"
  - oh interesting, once a Variable has a value, the = thing breaks again
  - Vars are Java-style final

- hey, looks like the error messages have goten better since publication

- the pattern of having a type atom (symbol) at the beginning of a tuple is interesting
- heady taily goodness
  - the fancy variants are nice

- The binary packing/unpacking in a pattern match thing is neat I
  guess, but maybe I'm missing something?
  - The REPL representations are baffling

- exporting things by arity :-/

- tail recursion FTW

* Day 2


* Day 3

